// ============= IN all.hpp =============
// Add these methods to Server class:
void SendMessage(int fd, const std::string& message);
void AuthenticateClient(int fd, const std::string& password);
void SetClientAuthenticated(int fd, bool status);
bool IsClientAuthenticated(int fd);

// Add these methods to Client class:
bool IsAuthenticated() const;
void SetAuthenticated(bool status);

// ============= IN Client.cpp (NEW FILE) =============
#include "all.hpp"

int Client::getAut(void) {
    return this->isAut;
}

bool Client::IsAuthenticated() const {
    return this->isAut == 1;
}

void Client::SetAuthenticated(bool status) {
    this->isAut = status ? 1 : 0;
}

// ============= IN Server.cpp (EXISTING FILE - ADD THESE FUNCTIONS) =============

void Server::SendMessage(int fd, const std::string& message) {
    std::string fullMessage = message + "\r\n";
    send(fd, fullMessage.c_str(), fullMessage.length(), 0);
}

void Server::AuthenticateClient(int fd, const std::string& password) {
    if (password == this->pass) {
        SetClientAuthenticated(fd, true);
        SendMessage(fd, ":server 001 * :Welcome to the IRC Server!");
        std::cout << GRE << "Client <" << fd << "> authenticated successfully" << WHI << std::endl;
    } else {
        SendMessage(fd, ":server 464 * :Password incorrect");
        std::cout << RED << "Client <" << fd << "> authentication failed" << WHI << std::endl;
    }
}

void Server::SetClientAuthenticated(int fd, bool status) {
    for (size_t i = 0; i < clients.size(); i++) {
        if (clients[i].GetFd() == fd) {
            clients[i].SetAuthenticated(status);
            break;
        }
    }
}

bool Server::IsClientAuthenticated(int fd) {
    for (size_t i = 0; i < clients.size(); i++) {
        if (clients[i].GetFd() == fd) {
            return clients[i].IsAuthenticated();
        }
    }
    return false;
}

// ============= IN commands.hpp =============
#ifndef COMMANDS_HPP
#define COMMANDS_HPP

#include <string>
class Server; // Forward declaration

class Acommands {
public:
    std::string getCommand(int fd, Server* server, const std::string& buffer);
    void handlePassCommand(int fd, Server* server, const std::string& password);
    void handleUserCommand(int fd, Server* server, const std::string& params);
    void handleNickCommand(int fd, Server* server, const std::string& nickname);
    void handleJoinCommand(int fd, Server* server, const std::string& channel);
    std::string trim(const std::string& str);
    std::vector<std::string> split(const std::string& str, char delimiter);
};

#endif

// ============= IN commands.cpp (NEW FILE) =============
#include "commands.hpp"
#include "all.hpp"
#include <sstream>
#include <algorithm>

std::string Acommands::trim(const std::string& str) {
    size_t start = str.find_first_not_of(" \t\r\n");
    if (start == std::string::npos) return "";
    size_t end = str.find_last_not_of(" \t\r\n");
    return str.substr(start, end - start + 1);
}

std::vector<std::string> Acommands::split(const std::string& str, char delimiter) {
    std::vector<std::string> tokens;
    std::stringstream ss(str);
    std::string token;
    while (std::getline(ss, token, delimiter)) {
        tokens.push_back(token);
    }
    return tokens;
}

std::string Acommands::getCommand(int fd, Server* server, const std::string& buffer) {
    std::string command = trim(buffer);
    if (command.empty()) return "Empty command";
    
    // Split command into parts
    std::vector<std::string> parts = split(command, ' ');
    if (parts.empty()) return "Invalid command";
    
    std::string cmd = parts[0];
    std::transform(cmd.begin(), cmd.end(), cmd.begin(), ::toupper);
    
    // Check if client is authenticated for commands that require auth
    if (cmd != "PASS" && !server->IsClientAuthenticated(fd)) {
        server->SendMessage(fd, ":server 451 * :You have not registered");
        return "Client not authenticated";
    }
    
    if (cmd == "PASS") {
        if (parts.size() < 2) {
            server->SendMessage(fd, ":server 461 PASS :Not enough parameters");
            return "PASS: Missing password";
        }
        handlePassCommand(fd, server, parts[1]);
        return "PASS command processed";
    }
    else if (cmd == "USER") {
        if (parts.size() < 5) {
            server->SendMessage(fd, ":server 461 USER :Not enough parameters");
            return "USER: Not enough parameters";
        }
        std::string params = command.substr(5); // Everything after "USER "
        handleUserCommand(fd, server, params);
        return "USER command processed";
    }
    else if (cmd == "NICK") {
        if (parts.size() < 2) {
            server->SendMessage(fd, ":server 431 * :No nickname given");
            return "NICK: No nickname given";
        }
        handleNickCommand(fd, server, parts[1]);
        return "NICK command processed";
    }
    else if (cmd == "JOIN") {
        if (parts.size() < 2) {
            server->SendMessage(fd, ":server 461 JOIN :Not enough parameters");
            return "JOIN: Missing channel";
        }
        handleJoinCommand(fd, server, parts[1]);
        return "JOIN command processed";
    }
    else {
        server->SendMessage(fd, ":server 421 " + cmd + " :Unknown command");
        return "Unknown command: " + cmd;
    }
}

void Acommands::handlePassCommand(int fd, Server* server, const std::string& password) {
    if (server->IsClientAuthenticated(fd)) {
        server->SendMessage(fd, ":server 462 * :You may not reregister");
        return;
    }
    
    server->AuthenticateClient(fd, password);
}

void Acommands::handleUserCommand(int fd, Server* server, const std::string& params) {
    // Basic USER command handling - in full IRC server you'd parse username, hostname, etc.
    server->SendMessage(fd, ":server 001 * :Welcome to the IRC Network");
}

void Acommands::handleNickCommand(int fd, Server* server, const std::string& nickname) {
    // Basic NICK command handling - in full IRC server you'd check for duplicates
    server->SendMessage(fd, ":server 001 * :Nickname set to " + nickname);
}

void Acommands::handleJoinCommand(int fd, Server* server, const std::string& channel) {
    // Basic JOIN command handling
    if (channel[0] != '#') {
        server->SendMessage(fd, ":server 403 " + channel + " :No such channel");
        return;
    }
    
    server->SendMessage(fd, ":user!" + channel + " JOIN " + channel);
    server->SendMessage(fd, ":server 353 * = " + channel + " :user");
    server->SendMessage(fd, ":server 366 * " + channel + " :End of NAMES list");
}

// ============= MODIFICATIONS TO EXISTING FILES =============

// In your main Server.cpp file, modify ReceiveNewData:
void Server::ReceiveNewData(int fd, Server *server) {
    Acommands commands;
    char buff[1024];
    memset(buff, 0, sizeof(buff));
    
    ssize_t bytes = recv(fd, buff, sizeof(buff) - 1, 0);
    
    if (bytes <= 0) {
        if (bytes == 0) {
            std::cout << RED << "Client <" << fd << "> Disconnected" << WHI << std::endl;
        } else {
            std::cerr << RED << "Error receiving data from client <" << fd << ">" << WHI << std::endl;
        }
        ClearClients(fd);
        close(fd);
        return;
    }
    
    buff[bytes] = '\0';
    std::cout << YEL << "Client <" << fd << "> Data: " << WHI << buff;
    
    // Process the command
    std::string result = commands.getCommand(fd, this, buff);
    std::cout << "Command result: " << result << std::endl;
}
